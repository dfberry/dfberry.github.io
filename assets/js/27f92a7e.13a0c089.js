"use strict";(self.webpackChunkdocusaurus_blog_with_search=self.webpackChunkdocusaurus_blog_with_search||[]).push([[7141],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=o.createContext({}),l=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(p.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=l(n),h=a,m=c["".concat(p,".").concat(h)]||c[h]||d[h]||r;return n?o.createElement(m,i(i({ref:t},u),{},{components:n})):o.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2976:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=n(7462),a=(n(7294),n(3905));const r={slug:"/2024-04-05-azure-functions-deploy-with-github.md",canonical_url:"https://dfberry.github.io/blog/2024-04-05-azure-functions-deploy-with-github.md",custom_edit_url:null,sidebar_label:"2024-04-05 Deploy Azure Functions with GitHub Actions",title:"Deploy an Azure Functions app from a monorepo with a GitHub Action for Node.js",description:"Monorepos for Node.js are a unique challenge with Azure functions. Learn 2 tricks to successfully deploy.",published:!1,tags:["Azure","Azure Functions","Developer Experience","Deploy"],updated:"2024-04-05 00:00 PST"},i="Deploy an Azure Functions app from a monorepo with a GitHub Action for Node.js",s={permalink:"/2024-04-05-azure-functions-deploy-with-github.md",source:"@site/blog/2024-04-05-azure-functions-deploy-with-github.md",title:"Deploy an Azure Functions app from a monorepo with a GitHub Action for Node.js",description:"Monorepos for Node.js are a unique challenge with Azure functions. Learn 2 tricks to successfully deploy.",date:"2024-04-05T00:00:00.000Z",formattedDate:"April 5, 2024",tags:[{label:"Azure",permalink:"/tags/azure"},{label:"Azure Functions",permalink:"/tags/azure-functions"},{label:"Developer Experience",permalink:"/tags/developer-experience"},{label:"Deploy",permalink:"/tags/deploy"}],readingTime:5.29,hasTruncateMarker:!1,authors:[],frontMatter:{slug:"/2024-04-05-azure-functions-deploy-with-github.md",canonical_url:"https://dfberry.github.io/blog/2024-04-05-azure-functions-deploy-with-github.md",custom_edit_url:null,sidebar_label:"2024-04-05 Deploy Azure Functions with GitHub Actions",title:"Deploy an Azure Functions app from a monorepo with a GitHub Action for Node.js",description:"Monorepos for Node.js are a unique challenge with Azure functions. Learn 2 tricks to successfully deploy.",published:!1,tags:["Azure","Azure Functions","Developer Experience","Deploy"],updated:"2024-04-05 00:00 PST"},nextItem:{title:"Add a database service to the API project",permalink:"/2024-01-21-cloud-native-008-api-database.md"}},p={authorsImageUrls:[]},l=[{value:"Single versus monorepo repositories",id:"single-versus-monorepo-repositories",level:2},{value:"Monorepo repositories as a single source of truth",id:"monorepo-repositories-as-a-single-source-of-truth",level:2},{value:"Azure Functions apps with Visual Studio Code",id:"azure-functions-apps-with-visual-studio-code",level:2},{value:"GitHub actions workflow file for Azure Functions monorepo app",id:"github-actions-workflow-file-for-azure-functions-monorepo-app",level:2}],u={toc:l},c="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Azure Functions apps can be locally deployed from Visual Studio Code using the Azure Functions extension or when you create the resource in the portal, you can configure deployment. These are straightforward when your app is the only thing in the repo but become a little more challenging in monorepos. "),(0,a.kt)("h2",{id:"single-versus-monorepo-repositories"},"Single versus monorepo repositories"),(0,a.kt)("p",null,"When you have a single function in a repo, the Azure Functions app is build and run from the root level package.json which is where hosting platforms look for those files. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"- package.json\n- package-lock.json\n- src\n    - functions\n        - hello-world.js\n")),(0,a.kt)("p",null,"In a monorepos, all these files are pushed down a level or two and there may or may not be a root-level package.json."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"- package.json\n- packages\n    - products\n        - package.json\n        - package-lock.json\n        - src\n            - functions\n                - product.js\n    - sales\n        - package.json\n        - package-lock.json\n        - src\n            - functions\n                - sales.js\n")),(0,a.kt)("p",null,"If there is a root-level package.json, it may control developer tooling across all packages. While you can deploy the entire repo to a hosting platform and configure which package is launched, this isn't necessary and may lead to problems. "),(0,a.kt)("h2",{id:"monorepo-repositories-as-a-single-source-of-truth"},"Monorepo repositories as a single source of truth"),(0,a.kt)("p",null,"Monorepo repositories allow you to collect all source code or at least all source code for a project into a single place. This is ideal for microservices or full-stack apps. There is an extra layer of team education and repository management in order to efficiently operationalize this type of repository. "),(0,a.kt)("p",null,"When starting the monorepo, you need to select the workspace management. I use npm workspaces but others exist. This requires a root-level package.json with the packages (source code projects) noted."),(0,a.kt)("p",null,"The syntax for npm workspaces allows you to select what is a package as well as what is not a package. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'...\n  "workspaces": [\n    "packages/*",           // include all packages under /packages\n    "!packages/legacy/*"    // except all packages under /packages/legacy\n  ],\n...\n')),(0,a.kt)("h2",{id:"azure-functions-apps-with-visual-studio-code"},"Azure Functions apps with Visual Studio Code"),(0,a.kt)("p",null,"When you create a Functions app with Visual Studio Code with the Azure Functions extension you can select it to be created at the root, or in a package. As part of that creation process, a ",(0,a.kt)("inlineCode",{parentName:"p"},".vscode")," folder is created with files to help find and debug the app. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"extensions.json: all Visual Studio Code extensions"),(0,a.kt)("li",{parentName:"ul"},"launch.json: debug"),(0,a.kt)("li",{parentName:"ul"},"settings.json: settings for extensions"),(0,a.kt)("li",{parentName:"ul"},"tasks.json: tasks for launch.json")),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"settings.json")," includes ",(0,a.kt)("inlineCode",{parentName:"p"},"azureFunctions.deploySubpath")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"azureFunctions.projectSubpath")," properties which tells Azure Functions where to find the source code. For a monorepo, the value of these settings may depend on the version of the extension you use. "),(0,a.kt)("p",null,"As of March 2024, setting the exact path has worked for me, such as ",(0,a.kt)("inlineCode",{parentName:"p"},"packages/sales/"),". "),(0,a.kt)("p",null,"If you don't set the correct path for these values, the correct package may not be used with the extension or the hosting platform won't find the correct package.json to launch the Node.js Functions app. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"During development: set the ",(0,a.kt)("inlineCode",{parentName:"li"},"azureFunctions.projectSubpath")," to the single package path you are developing."),(0,a.kt)("li",{parentName:"ul"},"During deployment: set the ",(0,a.kt)("inlineCode",{parentName:"li"},"azureFunctions.deploySubpath")," to the single package path so the hosting platform has the correct path to launch the app. ")),(0,a.kt)("h2",{id:"github-actions-workflow-file-for-azure-functions-monorepo-app"},"GitHub actions workflow file for Azure Functions monorepo app"),(0,a.kt)("p",null,"When you create a Azure Functions app in the Azure portal and configure the deployment, the default (and not editable) workflow file is built for a ",(0,a.kt)("strong",{parentName:"p"},"monorepo")," where the app's package.json is at the root of the repository."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"# Docs for the Azure Web Apps Deploy action: https://github.com/azure/functions-action\n# More GitHub Actions for Azure: https://github.com/Azure/actions\n\nname: Build and deploy Node.js project to Azure Function App - my-functions-app\n\non:\n  push:\n    branches:\n      - main\n  workflow_dispatch:\n\nenv:\n  AZURE_FUNCTIONAPP_PACKAGE_PATH: '.' # set this to the path to your web app project, defaults to the repository root\n  NODE_VERSION: '20.x' # set this to the node version to use (supports 8.x, 10.x, 12.x)\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 'Checkout GitHub Action'\n        uses: actions/checkout@v4\n\n      - name: Setup Node ${{ env.NODE_VERSION }} Environment\n        uses: actions/setup-node@v3\n        with:\n          node-version: ${{ env.NODE_VERSION }}\n\n      - name: 'Resolve Project Dependencies Using Npm'\n        shell: bash\n        run: |\n          pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'\n          npm install\n          npm run build --if-present\n          npm run test --if-present\n          popd\n\n      - name: Zip artifact for deployment\n        run: zip release.zip ./* -r\n\n      - name: Upload artifact for deployment job\n        uses: actions/upload-artifact@v3\n        with:\n          name: node-app\n          path: release.zip\n\n  deploy:\n    runs-on: ubuntu-latest\n    needs: build\n    environment:\n      name: 'production'\n      url: ${{ steps.deploy-to-webapp.outputs.webapp-url }}\n    permissions:\n      id-token: write #This is required for requesting the JWT\n\n    steps:\n      - name: Download artifact from build job\n        uses: actions/download-artifact@v3\n        with:\n          name: node-app\n\n      - name: Unzip artifact for deployment\n        run: unzip release.zip\n      \n      - name: Login to Azure\n        uses: azure/login@v1\n        with:\n          client-id: ${{ secrets.__clientidsecretname__ }}\n          tenant-id: ${{ secrets.__tenantidsecretname__ }}\n          subscription-id: ${{ secrets.__subscriptionidsecretname__ }}\n\n      - name: 'Run Azure Functions Action'\n        uses: Azure/functions-action@v1\n        id: fa\n        with:\n          app-name: 'dfberry-functions-single-ap'\n          slot-name: 'production'\n          package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}\n")),(0,a.kt)("p",null,"This worklow sets the ",(0,a.kt)("inlineCode",{parentName:"p"},"AZURE_FUNCTIONAPP_PACKAGE_PATH")," as the root of the project then pushes, ",(0,a.kt)("inlineCode",{parentName:"p"},"pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}'"),", into that path to build. The zip, ",(0,a.kt)("inlineCode",{parentName:"p"},"zip release.zip ./* -r"),", packages up everything as the root. To use a monorepo, these need to be altered. "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Change the name of the workflow to indicate the package and project."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"name: Build & deploy Azure Function - sales\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Create a new global ",(0,a.kt)("inlineCode",{parentName:"p"},"env")," parameter that sets the package location for the subdirectory source code. "),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"# set this to the path to your web app project \nAZURE_FUNCTIONAPP_PACKAGE_SALES_PATH: 'packages/sales' \n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Change the ",(0,a.kt)("inlineCode",{parentName:"p"},"Resolve Project Dependencies Using Npm")," to include the new environment variable."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"# pushd uses the package subdir as context for commands\npushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/${{ AZURE_FUNCTIONAPP_PACKAGE_SALES_PATH }}'\n")),(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"pushd")," commands moves the context into that sales subdirectory.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Change the ",(0,a.kt)("inlineCode",{parentName:"p"},"Zip artifact for deployment")," to include the new environment variable. The ",(0,a.kt)("inlineCode",{parentName:"p"},"popd")," command returns the context to the root of the project. "),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"# uses the root as context for the commands\nrun: | \n    pushd './${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}/${{ AZURE_FUNCTIONAPP_PACKAGE_SALES_PATH }}'\n    zip -r ../../release.zip dist/ package.json\n    popd\n")),(0,a.kt)("p",{parentName:"li"},"Using the ",(0,a.kt)("inlineCode",{parentName:"p"},"pushd")," command, change the location of the generated zip file to be in root directory. "),(0,a.kt)("p",{parentName:"li"},"The result is that the zip file's file structure looks like:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre"},"- package.json\n- src\n    - functions\n        - sales.js\n\n")),(0,a.kt)("p",{parentName:"li"},"If you intend to build TypeScript projects instead of JavaScript, you can alter the build and zip commands to use the generated ",(0,a.kt)("inlineCode",{parentName:"p"},"dist")," folder and the ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json"),"."))))}d.isMDXComponent=!0}}]);