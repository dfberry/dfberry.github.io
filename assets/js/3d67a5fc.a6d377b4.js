"use strict";(self.webpackChunkdocusaurus_blog_with_search=self.webpackChunkdocusaurus_blog_with_search||[]).push([[2767],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=o.createContext({}),i=function(e){var t=o.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=i(e.components);return o.createElement(d.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,d=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=i(n),h=a,m=c["".concat(d,".").concat(h)]||c[h]||u[h]||r;return n?o.createElement(m,s(s({ref:t},p),{},{components:n})):o.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=h;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[c]="string"==typeof e?e:a,s[1]=l;for(var i=2;i<r;i++)s[i]=n[i];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3682:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>i});var o=n(7462),a=(n(7294),n(3905));const r={slug:"/2024-01-21-cloud-native-008-api-database.md",canonical_url:"https://dfberry.github.io/blog/2024-01-21-cloud-native-008-api-database.md",custom_edit_url:null,sidebar_label:"2024.01-21 Add MongoDB to project",title:"Add a database service to the API project",description:"Add a data layer with the mongoose client to handle create, read, update, and delete operations for the API.",published:!1,tags:["Cloud-native","Database","MongoDB","Mongoose"],updated:"2024-01-21 00:00 PST"},s="Add database to the project",l={permalink:"/2024-01-21-cloud-native-008-api-database.md",source:"@site/blog/2024-01-21-cloud-native-008-api-database.md",title:"Add a database service to the API project",description:"Add a data layer with the mongoose client to handle create, read, update, and delete operations for the API.",date:"2024-01-21T00:00:00.000Z",formattedDate:"January 21, 2024",tags:[{label:"Cloud-native",permalink:"/tags/cloud-native"},{label:"Database",permalink:"/tags/database"},{label:"MongoDB",permalink:"/tags/mongo-db"},{label:"Mongoose",permalink:"/tags/mongoose"}],readingTime:11.145,hasTruncateMarker:!1,authors:[],frontMatter:{slug:"/2024-01-21-cloud-native-008-api-database.md",canonical_url:"https://dfberry.github.io/blog/2024-01-21-cloud-native-008-api-database.md",custom_edit_url:null,sidebar_label:"2024.01-21 Add MongoDB to project",title:"Add a database service to the API project",description:"Add a data layer with the mongoose client to handle create, read, update, and delete operations for the API.",published:!1,tags:["Cloud-native","Database","MongoDB","Mongoose"],updated:"2024-01-21 00:00 PST"},prevItem:{title:"Deploy an Azure Functions app from a monorepo with a GitHub Action for Node.js",permalink:"/2024-04-05-azure-functions-deploy-with-github.md"},nextItem:{title:"React Vite Client UI: quick Todo app proof of concept",permalink:"/2023-12-28-cloud-native-006-client-todo.md"}},d={authorsImageUrls:[]},i=[{value:"Add a MongoDB container to the development environment",id:"add-a-mongodb-container-to-the-development-environment",level:2},{value:"Visual Studio Code extension for MongoDB",id:"visual-studio-code-extension-for-mongodb",level:2},{value:"TODO shape",id:"todo-shape",level:2},{value:"Install mongoose to API",id:"install-mongoose-to-api",level:2},{value:"Connect to the database",id:"connect-to-the-database",level:2},{value:"TypeScript database service",id:"typescript-database-service",level:2},{value:"Use the CRUD class for collections",id:"use-the-crud-class-for-collections",level:2},{value:"Create the API routes and handlers",id:"create-the-api-routes-and-handlers",level:2},{value:"Test the APIs",id:"test-the-apis",level:2},{value:"Next step",id:"next-step",level:2}],p={toc:i},c="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The goal of ",(0,a.kt)("strong",{parentName:"p"},"iteration 008")," is to add a database to the project. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/dfberry/cloud-native-todo"},"Cloud-native-todo")," GitHub repo")),(0,a.kt)("p",null,"At this point, it doesn't matter if it is no-SQL, or SQL-based because there are no relationships or transactions. Someone suggested I look at Prisma for my ORM. After some testing, I realized a free Azure SQL database wasn't going to work because, Prisma requires a 2nd database, although only temporarily, for diffing the migrations. "),(0,a.kt)("p",null,"While I'm sure Prisma has its purpose, at this stage of the project, it seems like overkill compared to adding a database and client library I'm more familiar with. A point in the project where boring is good. "),(0,a.kt)("p",null,"Since I'm already on Azure, selecting some flavor of SQL Server or Cosmos DB makes sense if there is a consumption (pay-as-you-go) pricing tier (SKU) which is free-ish for such as small project. Mongoose and the Cosmos DB API for MongoDB are expedient choices given the wealth of documentation for both for TypeScript/JavaScript. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/azure/cosmos-db/mongodb/how-to-javascript-get-started?tabs=azure-cli%2Clinux"},"Mongo DB developer guide for Cosmos DB")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://mongoosejs.com/docs/guide.html"},"Mongoose documentation"))),(0,a.kt)("h2",{id:"add-a-mongodb-container-to-the-development-environment"},"Add a MongoDB container to the development environment"),(0,a.kt)("p",null,"All the local services are managed by Docker compose for local development where possible. Add the MongoDB container so development and testing don't incur any pay-as-you-go costs. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'version: "3"\n\nservices:\n  api-todo:\n    build:\n      context: ./api-todo\n    ports:\n      - "3000:3000"\n    depends_on:\n      - mongodb\n\n  client-todo:\n    build:\n      context: ./client-todo\n    environment:\n      VITE_USE_LOCAL_API: "true"\n      VITE_API_URL: http://localhost:3000\n    ports:\n      - "80:80"\n    depends_on:\n      - api-todo\n\n  mongodb:\n    image: mongo:5.0\n    restart: always\n    environment:\n      - MONGO_INITDB_ROOT_USERNAME=mongo\n      - MONGO_INITDB_ROOT_PASSWORD=MongoPass\n    ports:\n      - "27017:27017"\n    volumes:\n      - ./mongodata:/data/db\n\nvolumes:\n  mongodata:\n')),(0,a.kt)("p",null,"Start the service in a separate terminal with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker compose up mongodb\n")),(0,a.kt)("p",null,"I stole this idea from the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/azure-samples/contoso-real-estate"},"Contoso Real Estate")," project which has a wealth of development environment configuration for you to use. "),(0,a.kt)("p",null,"Now that the database is running, add the MongoDB viewer."),(0,a.kt)("h2",{id:"visual-studio-code-extension-for-mongodb"},"Visual Studio Code extension for MongoDB"),(0,a.kt)("p",null,"Make sure you add the ",(0,a.kt)("a",{parentName:"p",href:"https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode"},"MongoDB")," viewer extension to the development environment, in the ",(0,a.kt)("inlineCode",{parentName:"p"},"devcontainer.json"),". "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'    "customizations": {\n        "vscode": {\n            "extensions": [\n                ...other extensions,\n\n                "mongodb.mongodb-vscode",\n            ]\n        }\n    },\n')),(0,a.kt)("p",null,"You can add a connection with a connection string so this can be used for both local and cloud databases. "),(0,a.kt)("h2",{id:"todo-shape"},"TODO shape"),(0,a.kt)("p",null,"The shape of the TODO prior to this iteration was: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},"{\n  id: 123\n  title: 'Get Milk'\n}\n")),(0,a.kt)("p",null,"Update the shape to allow for data shape growth:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},"{\n  id: '65ad9ad0769c2853d2804f3f',\n  title: 'Get Milk',\n  description: 'the oaty kind',\n  createdAt: '2024-01-21T22:29:36.849Z',\n  updatedAt: ''\n}\n")),(0,a.kt)("p",null,"The title and description should have a max size to help the UI. "),(0,a.kt)("h2",{id:"install-mongoose-to-api"},"Install mongoose to API"),(0,a.kt)("p",null,"TypeScript types are already in the package so just install it. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install mongoose\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json")," shows ",(0,a.kt)("inlineCode",{parentName:"p"},'"mongoose": "^8.0.4",')," in the dependencies property. "),(0,a.kt)("h2",{id:"connect-to-the-database"},"Connect to the database"),(0,a.kt)("p",null,"Before jumping in with code in the API, make sure you can connect to the database with the client library. Design your schema and make sure any restrictions, validations, and transformations are complete. Leave the script in the repo, it will be handy for the next person onboarded to the project to not have to figure out how to connection and view data. Keep this connection script all as a single file. This allows someone new to the team and Mongoose to understand how the pieces fit together. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const mongoose = require('mongoose');\nconst Schema = mongoose.Schema;\n\nconst COLLECTION = 'TodoConnectionTest';\n\n// Run mongo with `docker compose up mongodb`\nconst URI = 'mongodb://mongo:MongoPass@localhost:27017/';\n\nconst TodoSchema = new Schema(\n  {\n    title: {\n      type: String,\n      unique: true,\n      minlength: 1,\n      maxlength: 40,\n    },\n    description: {\n      type: String,\n      maxlength: 1000,\n      default: null,\n    },\n    createdAt: {\n      type: String,\n    },\n    updatedAt: {\n      type: String,\n      default: null,\n    },\n  },\n  {\n    versionKey: false,\n    virtuals: true,\n  }\n);\n\nTodoSchema.virtual('id').get(function () {\n  return this._id.toHexString();\n});\n\n// Ensure virtual fields are serialised.\nTodoSchema.set('toJSON', {\n  virtuals: true,\n  versionKey: false,\n  transform: function (doc, ret) {\n    delete ret._id;\n  },\n});\n\nconst main = async () => {\n  // Connect to db\n  mongoose.connect(URI);\n\n  // Create a model\n  const TodoDb = mongoose.model(COLLECTION, TodoSchema);\n\n  // Using create\n  const saveResult1 = await TodoDb.create({\n    title: 'first todo',\n    description: 'description',\n    createdAt: new Date().toISOString(),\n  });\n  const transformed1 = saveResult1.toJSON();\n  console.log('Created lean--------------------------------');\n  console.log(transformed1);\n\n  // ADD MORE COMMANDS\n\n};\n\nmain()\n  .then(() => {\n    console.log('done');\n    mongoose.disconnect();\n  })\n  .catch((e) => {\n    console.log(e);\n  });\n")),(0,a.kt)("p",null,"Add a script to the ",(0,a.kt)("inlineCode",{parentName:"p"},"package.json")," so you can test the connection:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'"mongoose:test": "node ./scripts/test-mongo-connection.js"\n')),(0,a.kt)("h2",{id:"typescript-database-service"},"TypeScript database service"),(0,a.kt)("p",null,"Start with a generic CRUD class. All MongoDB collections will use this class to enforce consistency. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export default class CrudService<T> {\n  #model: Model<T>;\n\n  constructor(model: Model<T>) {\n    this.#model = model;\n  }\n\n  // Add\n  async add(doc: Partial<T>): Promise<T> {\n      const improvedDoc = {\n        ...doc,\n        createdAt: new Date().toISOString(),\n        updatedAt: null,\n      };\n      const data = await this.#model.create(improvedDoc);\n\n      return data?.toJSON();\n  }\n\n  // Read\n  async get(id: string): Promise<T> {\n\n      const data = await this.#model.findById(id);\n\n      return data: data?.toJSON();\n  }\n\n  // Update\n  async update(\n    id: string,\n    update: Partial<T>\n  ): Promise<T> {\n      const improvedDoc = { ...update, updatedAt: new Date().toISOString() };\n\n      const data = await this.#model.findByIdAndUpdate(id, improvedDoc, {\n        new: true,\n      });\n\n      return data?.toJSON();\n  }\n\n  // Delete\n  async delete(id: string): Promise<T> {\n      const data = await this.#model.findByIdAndDelete(id);\n\n      return data?.toJSON();\n  }\n\n  // Get All\n  async getAll(): Promise<T[]> {\n      const data = await this.#model.find();\n      return data;\n  }\n\n  // Delete All\n  async deleteAll(): Promise<unknown> {\n      const deleteAllResponse = await this.#model.deleteMany({});\n      return deleteAllResponse;\n  }\n\n  // Batch insert\n  async seed(docs: T[] | Partial<T>[]): Promise<T[]> {\n      const result = await this.#model.insertMany(docs);\n      return data;\n  }\n}\n")),(0,a.kt)("p",null,"MongoDB and the Mongoose client provide a high degree of configuration for what type of information to return from the mongoose calls. Its important to play with this in the previous script to determine what you want returned then apply those changes to this Crud class and the schema via the model that it uses. "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"strong"},"_id")," versus ",(0,a.kt)("inlineCode",{parentName:"strong"},"id")),": MongoDB stores the unique id as ",(0,a.kt)("inlineCode",{parentName:"li"},"_id")," but I want the REST API and the UI to only use ",(0,a.kt)("inlineCode",{parentName:"li"},"id"),". Any transformations need to be done at this data layer. If this data service was used for automation or other movement of data between backend services, that would probably require some strict contracts so an ambitious DBA didn't make assumptions that the native ",(0,a.kt)("inlineCode",{parentName:"li"},"_id")," was required. "),(0,a.kt)("li",{parentName:"ul"},"transformation on ",(0,a.kt)("strong",{parentName:"li"},"single versus multiple")," items: many of the convenience functions run a query inside the mongoose client which is meant to operate on multiple values. When running queries, transformations applied to a single object (such as with create()) aren't applied to the objects. You need to either transform the objects yourself, or provide an aggregation pipeline to make sure you get the shape returned which you expect. This means your tests need to validate the shape of objects for all CRUD operations where you want data returned. You may opt to have have the transformations applied at the CRUD class level and the schema level, if the owner of the application code and the owner of the schema object definition are different people. For example, the tests might include:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Test property property count"),(0,a.kt)("li",{parentName:"ul"},"Test property names"),(0,a.kt)("li",{parentName:"ul"},"Test that ",(0,a.kt)("inlineCode",{parentName:"li"},"_id")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"_v")," aren't returned"),(0,a.kt)("li",{parentName:"ul"},"Test a new item only has the createdAt date"),(0,a.kt)("li",{parentName:"ul"},"Test an updated item only has the updatedAt data"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"data returned"),": the mongoose client methods can return a stunning variety of values and information. For example, when updating, the returned information can include the data set in, the data after it was updated, or include the number of items which were updated. Be clear in your design when to return what kind of information. The API layer should only return what the UI needs. ")),(0,a.kt)("h2",{id:"use-the-crud-class-for-collections"},"Use the CRUD class for collections"),(0,a.kt)("p",null,"Create an interface to provide a data layer contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface IDataClass<T> {\n  add: (todo: Partial<T>) => Promise<T>;\n  get: (id: string) => Promise<T>;\n  getAll: () => Promise<T[]>;\n  update: (id: string, todo: Partial<T>) => Promise<T>;\n  delete: (id: string) => Promise<T>;\n  deleteAll: () => Promise<unknown>;\n  batch: (todos: T[]) => Promise<T[]>;\n}\n")),(0,a.kt)("p",null,"If there are specific validations or transformations for a collection, apply them at a layer above the generic CRUD class. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"export type CrudServiceResponse<T> = {\n  data: T | T[] | unknown | null;\n  error: Error | null | ValidationError | ValidationError[] | undefined;\n  valid?: boolean;\n};\n\nexport class TodoService implements IDataClass<Todo> {\n  #service: CrudService<Todo>;\n\n  constructor(connection: mongoose.Connection) {\n    const ConnectedTodoModel = connection.model<Todo>('Todo', TodoSchema);\n    this.#service = new CrudService<Todo>(ConnectedTodoModel);\n  }\n\n  async get(id: string): Promise<CrudServiceResponse<Todo>> {\n    if (!id) {\n      return { data: null, error: new Error('id is required') };\n    }\n\n    return await this.#service.get(id);\n  }\n\n  async add(todo: Partial<Todo>): Promise<CrudServiceResponse<Todo>> {\n    const { valid, error } = isValidPartial(todo);\n    if (!valid) {\n      return { data: null, error: error };\n    }\n    const addResponse = await this.#service.add(todo);\n    return addResponse;\n  }\n\n  async update(\n    id: string,\n    todo: Partial<Todo>\n  ): Promise<CrudServiceResponse<Todo>> {\n    if (!id) {\n      return { data: null, error: new Error('id is required') };\n    }\n\n    const { valid, error } = isValidPartial(todo);\n    if (!valid) {\n      return { data: null, error: error };\n    }\n\n    const updateResponse = await this.#service.update(id, {\n      title: todo.title as string,\n      description: todo.description as string,\n      updatedAt: new Date().toISOString(),\n    } as Todo);\n    return updateResponse;\n  }\n\n  async delete(id: string): Promise<CrudServiceResponse<Todo>> {\n    if (!id) {\n      return { data: null, error: new Error('id is required') };\n    }\n\n    return await this.#service.delete(id);\n  }\n  async getAll(): Promise<CrudServiceResponse<Todo[]>> {\n    return await this.#service.getAll();\n  }\n  async seed(\n    incomingTodos: Partial<Todo>[]\n  ): Promise<CrudServiceResponse<Todo[]>> {\n    return await this.#service.seed(incomingTodos);\n  }\n  async deleteAll(): Promise<CrudServiceResponse<Todo[]>> {\n    const deleteResponse = await this.#service.deleteAll();\n    return deleteResponse;\n  }\n}\n")),(0,a.kt)("h2",{id:"create-the-api-routes-and-handlers"},"Create the API routes and handlers"),(0,a.kt)("p",null,"The API is separated between individual and multiple items. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Multiples Routes\n\n// Create Todo router with all routes then export it\nconst todosRouter = express.Router();\n\ntodosRouter.get('/', getAllTodosHandler);\ntodosRouter.patch('/', batchUploadTodoHandler);\ntodosRouter.delete('/', deleteAllTodoHandler);\n\n// Catch-all route\ntodosRouter.all('*', (req, res) => {\n  sendResponse(req, res, StatusCodes.NOT_FOUND, { error: 'Not Found' });\n  return;\n});\ntodosRouter.use(handleError);\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Singles Routes\n// Create Todo router with all routes then export it\nconst todoRouter = express.Router();\n\ntodoRouter.get('/:id', getTodoHandler);\ntodoRouter.post('/', addTodoHandler);\ntodoRouter.put('/:id', updateTodoHandler);\ntodoRouter.delete('/:id', deleteTodoHandler);\n\n// Catch-all route\ntodoRouter.all('*', (req, res) => {\n  sendResponse(req, res, StatusCodes.NOT_FOUND, { error: 'Not Found' });\n  return;\n});\ntodoRouter.use(handleError);\n")),(0,a.kt)("p",null,"Pull in the routes to the Express app: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// Route that operates on a single todo\napp.use('/todo', todoRouter);\n\n// Route that operates on multiple todos\napp.use('/todos', todosRouter);\n")),(0,a.kt)("h2",{id:"test-the-apis"},"Test the APIs"),(0,a.kt)("p",null,"You can use cURL, Postman, or Supertest. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'## Single\ncurl -X GET http://localhost:3000/todo/65ac3b70d3adb5df333004d7 --verbose\ncurl -X POST -H "Content-Type: application/json" -d \'{"todo": {"title":"CURL New Todo", "description":"This is a new todo"}}\' http://localhost:3000/todo --verbose\ncurl -X PUT -H "Content-Type: application/json" -d \'{"todo": {"title":"CURL XXX Updated Todo", "description":"This is an updated todo"}}\' http://localhost:3000/todo/65ac3d1b4c60586e545b3628 --verbose\ncurl -X DELETE http://localhost:3000/todo/65ac396a9afd90f786ab1fee --verbose\n\n## Multiple\ncurl -X GET http://localhost:3000/todos --verbose\ncurl -X PATCH -H "Content-Type: application/json" -d @batch.json http://localhost:3000/todos/ --verbose\ncurl -X DELETE http://localhost:3000/todos --verbose\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import request from 'supertest';\nimport configureApp from './server'; // Import your Express app\nimport 'dotenv/config';\n\ndescribe('Todo API against running MongoDB', () => {\n  it('test all todo routes', async () => {\n    process.env.NODE_ENV = 'test';\n\n    const { app, connection } = await configureApp();\n    await request(app).delete('/todos');\n\n    // Add one\n    const addOneResponse = await request(app)\n      .post('/todo')\n      .send({\n        todo: {\n          title: 'Sa1 - ' + Date.now(),\n          description: 'Sa2 - ' + Date.now(),\n        },\n      });\n    testAdd(addOneResponse);\n\n    // // Update one\n    const updateOneResponse = await request(app)\n      .put('/todo/' + addOneResponse.body.data.id)\n      .send({\n        todo: {\n          title: 'Su1 - ' + Date.now(),\n          description: 'su2 ' + Date.now(),\n        },\n      });\n    testUpdate(updateOneResponse);\n\n    // // Delete `Sa1`, `Su1` should still be there\n    const deletedOneResponse = await request(app).delete(\n      '/todo/' + addOneResponse.body.data.id\n    );\n    testDelete(deletedOneResponse);\n\n    // Batch all - after this call 3 items should be in the database\n    // 3 B\n    const addThreeBody = {\n      todos: [\n        {\n          title: 'B1a ' + Date.now(),\n          description: 'B1b' + Date.now(),\n        },\n        {\n          title: 'B2a' + Date.now(),\n          description: 'B2b' + Date.now(),\n        },\n        {\n          title: 'B3a' + Date.now(),\n          description: 'B3b' + Date.now(),\n        },\n      ],\n    };\n    const batchResponse = await request(app).patch('/todos').send(addThreeBody);\n    testBatch(batchResponse);\n\n    // // Get All - should return four items\n    const getAllResponse = await request(app).get('/todos');\n    testGetAll(getAllResponse, 3);\n\n    // Delete All\n    const deleteAllResponse = await request(app).delete('/todos');\n    testDeleteAll(deleteAllResponse, 3);\n\n    if (connection) {\n      connection.close();\n    }\n  }, 30000);\n});\n")),(0,a.kt)("p",null,"Make sure you validate the data returned:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"//write a function to test the shape of a Todo\nconst testTodoShape = (todo) => {\n  const keys = Object.keys(todo);\n\n  expect(keys.length).toEqual(5);\n  expect(keys).toContainEqual('id');\n  expect(keys).toContainEqual('title');\n  expect(keys).toContainEqual('description');\n  expect(keys).toContainEqual('createdAt');\n  expect(keys).toContainEqual('updatedAt');\n};\nconst testTodoArrayShape = (todos) => {\n  expect(todos).toBeInstanceOf(Array);\n  todos.forEach(testTodoShape);\n};\n\nconst testAdd = (addResponse) => {\n  // operational error\n  expect(addResponse.error).toEqual(false);\n\n  const { status, body } = addResponse;\n  expect(status).toEqual(201);\n  const { data, error } = body;\n  expect(error).toEqual(null);\n  expect(data).not.toEqual(null);\n  testTodoShape(data);\n};\n\nconst testUpdate = (updateResponse) => {\n  // operational error\n  expect(updateResponse.error).toEqual(false);\n\n  const { status, body } = updateResponse;\n  expect(status).toEqual(202);\n  const { data, error } = body;\n  expect(error).toEqual(null);\n  expect(data).not.toEqual(null);\n  testTodoShape(data);\n};\n\nconst testDelete = (deleteResponse) => {\n  // operational error\n  expect(deleteResponse.error).toEqual(false);\n\n  const { status, body } = deleteResponse;\n  expect(status).toEqual(202);\n  const { data, error } = body;\n  expect(error).toEqual(null);\n  expect(data).not.toEqual(null);\n  testTodoShape(data);\n};\n\nconst testBatch = (batchResponse) => {\n  // operational error\n  expect(batchResponse.error).toEqual(false);\n\n  const { status, body } = batchResponse;\n  expect(status).toEqual(201);\n  const { data, error } = body;\n  expect(error).toEqual(null);\n  expect(data).not.toEqual(null);\n  testTodoArrayShape(data);\n};\n\nconst testGetAll = (getAllResponse, dataLength) => {\n  // operational error\n  expect(getAllResponse.error).toEqual(false);\n\n  const { status, body } = getAllResponse;\n  expect(status).toEqual(200);\n  const { data, error } = body;\n  expect(error).toEqual(null);\n  expect(data).not.toEqual(null);\n  expect(data.length).toEqual(dataLength);\n  testTodoArrayShape(data);\n};\n\nconst testDeleteAll = (deleteAllResponse, dataLength) => {\n  // operational error\n  expect(deleteAllResponse.error).toEqual(false);\n\n  const { status, body } = deleteAllResponse;\n  expect(status).toEqual(202);\n  const { data, error } = body;\n  expect(error).toEqual(null);\n  expect(data).not.toEqual(null);\n  expect(data.deletedCount).toEqual(dataLength);\n};\n")),(0,a.kt)("h2",{id:"next-step"},"Next step"),(0,a.kt)("p",null,"The next step is to add this functionality to the cloud environment."))}u.isMDXComponent=!0}}]);