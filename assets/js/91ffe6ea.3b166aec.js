"use strict";(self.webpackChunkdocusaurus_blog_with_search=self.webpackChunkdocusaurus_blog_with_search||[]).push([[6387],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),d=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return o.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=a,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||r;return n?o.createElement(h,i(i({ref:t},p),{},{components:n})):o.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var d=2;d<r;d++)i[d]=n[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3072:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var o=n(7462),a=(n(7294),n(3905));const r={slug:"/2023-12-28-cloud-native-006-client-todo.md",canonical_url:"https://dfberry.github.io/blog/2023-12-28-cloud-native-006-client-todo.md",custom_edit_url:null,sidebar_label:"2023.12-28 Cloud native client",title:"React Vite Client UI: quick Todo app proof of concept",description:"Create Client UI with Vite React and ViTest",published:!1,tags:["Cloud-native","Client UI","React","Vite and ViTest"],updated:"2023-12-28 00:00 PST"},i="React Vite Client UI: quick Todo app proof of concept",s={permalink:"/2023-12-28-cloud-native-006-client-todo.md",source:"@site/blog/2023-12-28-cloud-native-006-client-todo.md",title:"React Vite Client UI: quick Todo app proof of concept",description:"Create Client UI with Vite React and ViTest",date:"2023-12-28T00:00:00.000Z",formattedDate:"December 28, 2023",tags:[{label:"Cloud-native",permalink:"/tags/cloud-native"},{label:"Client UI",permalink:"/tags/client-ui"},{label:"React",permalink:"/tags/react"},{label:"Vite and ViTest",permalink:"/tags/vite-and-vi-test"}],readingTime:10.525,hasTruncateMarker:!1,authors:[],frontMatter:{slug:"/2023-12-28-cloud-native-006-client-todo.md",canonical_url:"https://dfberry.github.io/blog/2023-12-28-cloud-native-006-client-todo.md",custom_edit_url:null,sidebar_label:"2023.12-28 Cloud native client",title:"React Vite Client UI: quick Todo app proof of concept",description:"Create Client UI with Vite React and ViTest",published:!1,tags:["Cloud-native","Client UI","React","Vite and ViTest"],updated:"2023-12-28 00:00 PST"},prevItem:{title:"Add a database service to the API project",permalink:"/2024-01-21-cloud-native-008-api-database.md"},nextItem:{title:"Deploy to Azure from GitHub with Azure Developer CLI",permalink:"/2023-12-10-deploy-from-github.md"}},l={authorsImageUrls:[]},d=[{value:"Front-end framework choices and ChatGPT",id:"front-end-framework-choices-and-chatgpt",level:2},{value:"Creating the basic Vite React app",id:"creating-the-basic-vite-react-app",level:2},{value:"Add environment variable for API",id:"add-environment-variable-for-api",level:2},{value:"Clean up the app",id:"clean-up-the-app",level:2},{value:"Add the page, form, list, and item",id:"add-the-page-form-list-and-item",level:2},{value:"Add ViTest UI tests",id:"add-vitest-ui-tests",level:2},{value:"Where was CoPilot in this iteration?",id:"where-was-copilot-in-this-iteration",level:2},{value:"Where to next?",id:"where-to-next",level:2}],p={toc:d},c="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(c,(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dfberry/cloud-native-todo/tree/006-client-todo"},"sixth iteration")," of the cloud-native project, ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dfberry/cloud-native-todo"},"https://github.com/dfberry/cloud-native-todo"),", added the client UI to the monorepo. "),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://youtu.be/HTdVSKhnXek"},"YouTube demo")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Use Vite React to create basic project structure. "),(0,a.kt)("li",{parentName:"ol"},"Add React page and components for Todo: form, list, item."),(0,a.kt)("li",{parentName:"ol"},"Add Tests for components. "),(0,a.kt)("li",{parentName:"ol"},"Add API integration.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Reminder:")," A quick reminder that this project is using an in-memory DB at this point in the API. Each step of the way is meant to bootstrap the next step for speed instead of complete build out. This step is focusing on a bare-bones UI that interacts with the API. ")),(0,a.kt)("h2",{id:"front-end-framework-choices-and-chatgpt"},"Front-end framework choices and ChatGPT"),(0,a.kt)("p",null,"This iteration is a proof of concept (POC) that can grow, as opposed to being thrown away. With that in mind, I picked Vite React as the frontend framework. I'm comfortable with React and I like the Vite toolchain. "),(0,a.kt)("p",null,"In this day and age of ChatGPT everywhere, does it matter what framework you pick for a POC? This is up to you. Whatever answers or code your AI partner (such as ChatGPT) gives you, you still need to be able to integrate it and debug it. I suggest you pick something that you work with as though ChatGPT weren't available. If your team knows a different stack, and that stack has any duration (not built in the last year), go with that stack. "),(0,a.kt)("p",null,"I considered ",(0,a.kt)("a",{parentName:"p",href:"https://nextjs.org/"},"Next.js"),", plain ",(0,a.kt)("a",{parentName:"p",href:"https://react.dev/"},"React"),", ",(0,a.kt)("a",{parentName:"p",href:"https://vitejs.dev/"},"Vite")," React, and ",(0,a.kt)("a",{parentName:"p",href:"https://create-react-app.dev/"},"create-react-app")," (CRA). The POC needs velocity but not at the risk of the velocity or chaos of the underlying stack:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Next.js")," is a great framework but has its own ideas about the cloud. "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Plain React")," means building out my own toolchain -- a waste of time compared to Next, Vite, CRA and other stacks that provide that. "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Create React App")," has had some bumps in the road the last few years. Reminds me of the Angular 2,3,4,5 releases which is why I don't use Angular anymore. "),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Vite")," has been dependable in the last few projects so I'm sticking with that. ChatGPT answers enough of the Vite config and ViTest questions so that's a plus. ")),(0,a.kt)("h2",{id:"creating-the-basic-vite-react-app"},"Creating the basic Vite React app"),(0,a.kt)("p",null,"Vite has a quick ability to scaffold out the app with the CLI for a variety of front-end frameworks including React, Vue, and Svelte, and Electron. I chose TypeScript and SWC."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm create vite@latest\n")),(0,a.kt)("p",null,"This gives a basic runnable app with ESLint already configured. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "vite-project",\n  "private": true,\n  "version": "0.0.0",\n  "type": "module",\n  "scripts": {\n    "dev": "vite",\n    "build": "tsc && vite build",\n    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",\n    "preview": "vite preview"\n  },\n  "dependencies": {\n    "react": "^18.2.0",\n    "react-dom": "^18.2.0"\n  },\n  "devDependencies": {\n    "@types/react": "^18.2.43",\n    "@types/react-dom": "^18.2.17",\n    "@typescript-eslint/eslint-plugin": "^6.14.0",\n    "@typescript-eslint/parser": "^6.14.0",\n    "@vitejs/plugin-react-swc": "^3.5.0",\n    "eslint": "^8.55.0",\n    "eslint-plugin-react-hooks": "^4.6.0",\n    "eslint-plugin-react-refresh": "^0.4.5",\n    "typescript": "^5.2.2",\n    "vite": "^5.0.8"\n  }\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"vite.config.ts")," is where all the configuration goes."),(0,a.kt)("h2",{id:"add-environment-variable-for-api"},"Add environment variable for API"),(0,a.kt)("p",null,"Create a ",(0,a.kt)("inlineCode",{parentName:"p"},".env")," file and add an environment variable prefixed with ",(0,a.kt)("inlineCode",{parentName:"p"},"VITE_")," for the API URL such as ",(0,a.kt)("inlineCode",{parentName:"p"},"http://localhost:3000"),". When the client is deployed to the host, this URL will need to be changes and the front-end client build with the correct cloud URL. This URL is used later to build out the full API URL to fetch results:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const ENV_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';\nif(!ENV_URL) {\n  console.log('VITE_API_URL is not defined');\n}\n\nexport const API_URL = `${ENV_URL}/todo`;\n")),(0,a.kt)("p",null,"For this POC, a simple API service looks like: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"import { NewTodo } from './models';\n\nconst ENV_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';\nif(!ENV_URL) {\n  console.log('VITE_API_URL is not defined');\n}\n\nexport const API_URL = `${ENV_URL}/todo`;\n\nexport const addTodo = async (newTodo: NewTodo): Promise<Response> => {\n    return await fetch(API_URL, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(newTodo),\n      });\n    };\nexport const deleteTodo = async (id: number): Promise<Response> => {\n    return await fetch(`${API_URL}/${id}`, {\n        method: 'DELETE',\n      });\n    };\n")),(0,a.kt)("h2",{id:"clean-up-the-app"},"Clean up the app"),(0,a.kt)("p",null,"The main boilerplate for the Vite React app has a few things going on but none of which this POC needs at this point."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-JSX"},'import { useState } from \'react\'\nimport reactLogo from \'./assets/react.svg\'\nimport viteLogo from \'/vite.svg\'\nimport \'./App.css\'\n\nfunction App() {\n  const [count, setCount] = useState(0)\n\n  return (\n    <>\n      <div>\n        <a href="https://vitejs.dev" target="_blank">\n          <img src={viteLogo} className="logo" alt="Vite logo" />\n        </a>\n        <a href="https://react.dev" target="_blank">\n          <img src={reactLogo} className="logo react" alt="React logo" />\n        </a>\n      </div>\n      <h1>Vite + React</h1>\n      <div className="card">\n        <button onClick={() => setCount((count) => count + 1)}>\n          count is {count}\n        </button>\n        <p>\n          Edit <code>src/App.tsx</code> and save to test HMR\n        </p>\n      </div>\n      <p className="read-the-docs">\n        Click on the Vite and React logos to learn more\n      </p>\n    </>\n  )\n}\n\nexport default App\n')),(0,a.kt)("p",null,"Replace the contents with a pared-down component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-JSX"},"import './App.css'\n\nimport Todo from './todo'\n\nfunction App() {\n\n  return (\n    <>\n        <Todo />\n    </>\n  )\n}\n\nexport default App\n")),(0,a.kt)("h2",{id:"add-the-page-form-list-and-item"},"Add the page, form, list, and item"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"To keep the client UI clean and clear, create a new subfolder for everything for the Todo named ",(0,a.kt)("inlineCode",{parentName:"p"},"todo"),".")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Create the main todo page, ",(0,a.kt)("inlineCode",{parentName:"p"},"index.tsx"),", which handled the events, API call, and child rerenders. "),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-JSX"},"import { useState } from 'react';\nimport useSWR, { mutate } from 'swr';\nimport TodoForm from './components/form';\nimport List from './components/list';\nimport { NewTodo, Todo } from './models';\nimport { API_URL, addTodo, deleteTodo } from './service';\nimport { fetcher } from './api';\n\nexport default function Todo() {\n    const [requestError, setRequestError] = useState('');\n    const { data, error, isLoading } = useSWR(API_URL, fetcher)\n\n    async function handleSubmit(newTodoItem: NewTodo) {\n        setRequestError('');\n\n        try {\n            const result = await addTodo(newTodoItem);\n\n            if (!result.ok) throw new Error(`result: ${result.status} ${result.statusText}`);\n            const savedTodo = await result.json();\n            mutate(API_URL, [...data, savedTodo], false);\n\n        } catch (error: unknown) {\n            setRequestError(String(error));\n        }\n    }\n\n    async function handleDelete(id: number) {\n        setRequestError('');\n        try {\n            const result = await deleteTodo(id);\n            if (!result.ok) throw new Error(`result: ${result.status} ${result.statusText}`);\n            mutate(API_URL, data.filter((todo: Todo) => todo.id !== id), false);\n        } catch (error: unknown) {\n            setRequestError(String(error));\n        }\n    }\n\n    if (error && requestError) return <div>failed to load {error ? JSON.stringify(error) : requestError}</div>\n    if (isLoading) return <div>loading...{JSON.stringify(isLoading)}</div>\n\n    return (\n        <div>\n            <TodoForm onSubmit={handleSubmit} requestError={requestError} />\n            <div>\n                <List todos={data} onDelete={handleDelete} />\n            </div>\n        </div>\n    )\n}\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Create the listing, ",(0,a.kt)("inlineCode",{parentName:"p"},"components/list.tsx"),", to display the 3 default todos."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-JSX"},"import { Todo } from '../models';\nimport Item from './item';\n\nexport type { Todo };\n\ninterface Props {\ntodos: Todo[];\nonDelete: (id: number) => void;\n}\n\nexport default function List({ todos, onDelete }: Props) {\nreturn (\n\n    todos.length > 0 && (\n    <table style={{ width: '100%', marginTop: '20px'}} data-testid=\"list\">\n        <thead>\n        <tr>\n            <th >ID</th>\n            <th >Title</th>\n            <th >Delete</th>\n        </tr>\n        </thead>\n        <tbody>\n        {todos.map((todo) => (\n            <Item\n            key={todo.id}\n            todo={todo}\n            onDelete={onDelete}\n            />\n        ))}\n        </tbody>\n    </table>\n    )\n)\n}\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Add the Item, ",(0,a.kt)("inlineCode",{parentName:"p"},"components/item.tsx"),", to display each item. "),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'import { Todo } from \'../models\';\n\nexport type { Todo };\n\nexport interface ItemProps {\ntodo: Todo;\nonDelete: (id: number) => void;\n}\n\nexport default function Item({ todo, onDelete }: ItemProps) {\n\nreturn (\n    <tr data-testid="item-row">\n    <td data-testid="item-id">{todo.id}</td>\n    <td data-testid="item-title">{todo.title}</td>\n    <td data-testid="item-delete">\n        <button onClick={() => onDelete(todo.id)} >X</button>\n    </td>\n    </tr>\n);\n}\n')),(0,a.kt)("p",{parentName:"li"},"Notice the attributes for testing, named ",(0,a.kt)("inlineCode",{parentName:"p"},"data_testid")," are included already. ")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Add the Form, ",(0,a.kt)("inlineCode",{parentName:"p"},"components/form.tsx"),", to capture a new todo item."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'import { FormEvent, KeyboardEvent, ChangeEvent, useRef, useState } from \'react\';\nimport { NewTodo } from \'../models\';\n\nexport type { NewTodo };\n\ninterface Props {\n    onSubmit: (newTodoItem: NewTodo) => void;\n    requestError?: string;\n}\nexport default function TodoForm({ onSubmit, requestError }: Props) {\n    const formRef = useRef<HTMLFormElement>(null);\n    const [newTodo, setNewTodo] = useState<NewTodo>({ title: \'\' });\n\n    const handleSubmit = (event: FormEvent<HTMLFormElement>) => {\n        event.preventDefault();\n        const formData = new FormData(event.currentTarget);\n        const title = formData.get(\'title\')?.toString() || null;\n\n        if (title !== null) {\n\n            onSubmit({\n                title\n            });\n            if (formRef.current) {\n                formRef.current.reset();\n            }\n            // Reset the newTodo state\n            setNewTodo({ title: \'\' });\n        }\n    }\n\n    const handleKeyDown = (event: KeyboardEvent<HTMLInputElement>) => {\n        if (event.key === \'Enter\') {\n            if (formRef.current) {\n                formRef.current.dispatchEvent(new Event(\'submit\', { cancelable: true }));\n            }\n        }\n    };\n    const handleInputChange = (event: ChangeEvent<HTMLInputElement>) => {\n        setNewTodo({\n            title: event.target.value,\n        });\n    };\n    return (\n        <div >\n            <div>\n                <h1 >What do you have to do?</h1>\n            </div>\n            <form ref={formRef} onSubmit={handleSubmit} data-testid="todo-form">\n                <div >\n                    <input\n                        id="todoTitle"\n                        name="title"\n                        type="text"\n                        value={newTodo.title}\n                        placeholder="Title"\n                        onChange={handleInputChange}\n                        onKeyDown={handleKeyDown}\n                        data-testid="todo-form-input-title"\n                    />\n                </div>\n                {requestError && (\n                    <div data-testid="todo-error">\n                        {requestError}\n                    </div>\n                )}\n                <button type="submit" disabled={!newTodo.title} data-testid="todo-button">Add Todo</button>\n            </form>\n        </div>\n    );\n} \n'))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Add any dependency code such as the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dfberry/cloud-native-todo/blob/006-client-todo/client-todo/src/todo/service.ts"},"API service")," and its API ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dfberry/cloud-native-todo/blob/006-client-todo/client-todo/src/todo/api.ts"},"fetcher")," for SWR, and the TypeScript ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dfberry/cloud-native-todo/blob/006-client-todo/client-todo/src/todo/models.ts"},"models")," for a new todo and an existing todo. ")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Start the API and the client UI to use the form."),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"Browser todo app",src:n(5760).Z,width:"647",height:"420"})),(0,a.kt)("p",{parentName:"li"},"The form accepts a title to add a new todo, or deletes a todo using the X on each item's room. "))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note:")," This UI isn't styled and the little style that is there is mostly defaults. If you aren't comfortable with CSS or style libraries, use ChatGPT and GitHub CoPilot for this.")),(0,a.kt)("h2",{id:"add-vitest-ui-tests"},"Add ViTest UI tests"),(0,a.kt)("p",null,"Now that the bare bones proof of concept is working, add the UI tests to validate it. This is important so that any future changes to the app don't break existing functionality. "),(0,a.kt)("p",null,"The tests cover the following simple cases:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"renders form without error"),(0,a.kt)("li",{parentName:"ul"},"renders form with error"),(0,a.kt)("li",{parentName:"ul"},"renders button disabled"),(0,a.kt)("li",{parentName:"ul"},"renders button enabled"),(0,a.kt)("li",{parentName:"ul"},"accepts input text"),(0,a.kt)("li",{parentName:"ul"},"submit form by button"),(0,a.kt)("li",{parentName:"ul"},"submit form by keypress enter"),(0,a.kt)("li",{parentName:"ul"},"item component deletes item"),(0,a.kt)("li",{parentName:"ul"},"renders List with todos"),(0,a.kt)("li",{parentName:"ul"},"does not render List when todos is empty")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Add ",(0,a.kt)("a",{parentName:"p",href:"https://vitest.dev/guide/"},"ViTest")," following the instructions for that site and a few other packages for ",(0,a.kt)("a",{parentName:"p",href:"https://vitest.dev/guide/ui.html"},"testing UI with ViTest"),". Refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/dfberry/cloud-native-todo/blob/006-client-todo/client-todo/package.json"},"package.json")," for the complete list."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"npm install -D vitest @vitest/ui\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Create the ",(0,a.kt)("inlineCode",{parentName:"p"},"vitest.config.ts")," file for configurations:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-TypeScript"},"import path from 'node:path';\nimport { defineConfig, defaultExclude } from 'vitest/config';\nimport configuration from './vite.config';\n\nconst config = {\n    ...configuration,\n    test: {\n        reporters: ['json', 'default'],\n        outputFile: { json: \"./test-output/test-results.json\" },\n        globals: true,\n        setupFiles: path.resolve(__dirname, 'test/setup.ts'),\n        exclude: [...defaultExclude],\n        environmentMatchGlobs: [\n            ['**/*.test.tsx', 'jsdom'],\n            ['**/*.component.test.ts', 'jsdom'],\n        ]\n    },\n};\n\nexport default defineConfig(config);     \n")),(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"outputFile")," keeps the output files out of the way. The ",(0,a.kt)("inlineCode",{parentName:"p"},"setupFiles")," also keep the test setup files tucked away. ")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The hardest part about getting these tests to work was the TypeScript types for the testing library user events such as ",(0,a.kt)("inlineCode",{parentName:"p"},"await user.type(input, title)"),". The test setup and utility files helped with that. If you run into this, make sure to restart your TS Server in Visual Studio Code as well. "),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-TypeScript"},"// test/setup.ts\nimport '@testing-library/jest-dom/vitest';\n")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// test/utilities.ts\nimport type { ReactElement } from 'react';\nimport { render as renderComponent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\ntype RenderOptions = Parameters<typeof renderComponent>[1];\n\nexport * from '@testing-library/react';\n\nexport const render = (ui: ReactElement, options?: RenderOptions) => {\n    return {\n        ...renderComponent(ui, options),\n        user: userEvent.setup(),\n    };\n};\n```\n")),(0,a.kt)("ol",{start:4},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Then the User event test, such as the following, builds and runs."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-TypeScript"},"test('submit form by keypress enter', async () => {\n\n    // new title\n    const title = 'Test Todo';\n\n    // mock add function\n    const mockAdd = vi.fn();\n\n    // render the component\n    const { user, getByTestId } = render(<TodoForm onSubmit={mockAdd}/>);\n\n    // Fill in the input\n    const input = getByTestId('todo-form-input-title');\n    await user.type(input, title);\n\n    // submit form by keypress\n    await user.type(input, '{enter}');\n\n    // todo submitted to parent via onSubmit\n    expect(mockAdd).toHaveBeenCalledTimes(1);\n    expect(mockAdd).toHaveBeenCalledWith({ title });\n})\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Run the test with ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run test")," and see the results:"),(0,a.kt)("p",{parentName:"li"},(0,a.kt)("img",{alt:"Visual Studio Code terminal running tests",src:n(7092).Z,width:"671",height:"526"})))),(0,a.kt)("h2",{id:"where-was-copilot-in-this-iteration"},"Where was CoPilot in this iteration?"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Where did CoPilot succeed?")," "),(0,a.kt)("p",null,"CoPilot came in handy in some of the places that I'm happy to let to handle: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Quick CSS tweaks - it's much faster to play with CSS when CoPilot is generating styles over and over."),(0,a.kt)("li",{parentName:"ul"},"Config files - I was surprised by how much CoPilot helped with Vite and ViTest. "),(0,a.kt)("li",{parentName:"ul"},"Components - it wrote most of the component code, I asked for refactors and it provided those as well."),(0,a.kt)("li",{parentName:"ul"},"Tests - it wrote most of the UI tests for me in seconds.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Where did CoPilot fail?")," "),(0,a.kt)("p",null,"The tricky parts of integration, especially across tools, dependencies, and versions are still tricky. I spent the most time on the TypeScript issue with the testing library for user events. The fix came from a StackOverflow post which I had to look for. Considering all the layers involved and the time already saved in other places I used CoPilot and ChatGPT, that seems like net positive time savings for a proof of concept. "),(0,a.kt)("h2",{id:"where-to-next"},"Where to next?"),(0,a.kt)("p",null,"Now that the UI code is written and works locally, the project needs a container for the UI, and it needs to provision the UI resources for that container in the cloud. The client container needs to talk to the API container correctly. Fun stuff!"))}u.isMDXComponent=!0},5760:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/browser-todo-app-ui-6717d95f9a17c781cde44940c3efcefb.png"},7092:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/visual-studio-code-terminal-vitest-result-8f2c3d46f58eaf22ea0e3e174fe3b069.png"}}]);